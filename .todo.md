# TODO

## Current Sprint: StateManager + LogStore Architecture

This refactor centralizes log storage in a `StateManager`, enabling HTTP API access for LLM tools while keeping the TUI performant.

### Phase 1: Core Types (`cdi-shared/src/`)

#### File: `log.rs`
- [x] Add `Stream` enum (Stdout, Stderr)
- [x] Add `ProcessStatus` enum (Running, Stopped, Crashed)
- [ ] Add `SessionInfo` struct (id: u64, started_at: u64)
- [x] Add `ProcessInfo` struct
    - `id: u64` - stable hash from (name, command, cwd)
    - `name: String`
    - `command: String` 
    - `cwd: Option<String>`
    - `pid: Option<usize>` - OS pid, None if not yet started
    - `status: ProcessStatus`
    - `exit_code: Option<i32>`
- [x] Add `LogLine` struct
    - `id: u64` - per-process monotonic
    - `process_id: u64` - stable hash, correlates across sessions
    - `session_id: u64` - which run of the tool
    - `timestamp: u64` - unix millis
    - `stream: Stream`
    - `content: String`
- [ ] Add `compute_process_id(name, command, cwd) -> u64` helper function

#### File: `event/store.rs`
- [x] RoCell-based channel implemented
- [ ] Update `StoreEvent::AppendLog` to use `process_id: u64` (currently usize)
- [ ] Update `StoreEvent::ProcessExited` to use `process_id: u64` and `ProcessStatus` enum (currently uses String for both)

#### File: `event/ui.rs`
- [x] Renamed `Event` to `TuiEvent`
- [x] Removed `ProcessMessage` variant (commented out)

#### File: `lib.rs`
- [x] Export new modules (event, ro_cell, log)

### Phase 2: LogStore (`cdi-server/src/store/`)

#### New file: `mod.rs`
- [ ] Define `LogStore` trait
    - `append(&mut self, process: &str, stream: Stream, content: String) -> LogLine`
    - `get_lines(&self, process: &str, limit: usize) -> Vec<&LogLine>`
    - `get_lines_since(&self, process: &str, since_id: u64) -> Vec<&LogLine>`
    - `get_process(&self, name: &str) -> Option<&ProcessInfo>`
    - `get_processes(&self) -> Vec<&ProcessInfo>`
    - `set_process_status(&mut self, name: &str, status: ProcessStatus, exit_code: Option<i32>)`

#### New file: `memory.rs`
- [ ] Implement `InMemoryStore`
    - Ring buffer per process (configurable max lines, e.g., 10,000)
    - `HashMap<String, VecDeque<LogLine>>` for logs
    - `HashMap<String, ProcessInfo>` for process metadata
    - Lazily create storage on first `append()` for unknown process
    - Monotonic id counter per process

### Phase 3: StateManager (`cdi-server/src/state/`)

#### New file: `mod.rs`
- [ ] Create `StateManager` struct
    - Owns `InMemoryStore` (concrete type for now, trait later if needed)
    - Receives `StoreEvent` via `StoreEvent::take()`
    - Runs in its own tokio task
    - On `AppendLog` → writes to store, emits `Event::Render`
    - On `ProcessExited` → updates process status, emits `Event::Render`

#### New file: `handle.rs`
- [ ] Create `StateHandle` struct (clonable, shareable)
    - `store: Arc<RwLock<InMemoryStore>>` - direct read access for HTTP/TUI
    - `fn blocking_read(&self) -> RwLockReadGuard<InMemoryStore>` - for TUI
    - `async fn read(&self) -> RwLockReadGuard<InMemoryStore>` - for HTTP
- [ ] `StateManager::start()` returns `StateHandle`

### Phase 4: Refactor Supervisor & Process (`cdi-server/src/`)

#### Update: `server.rs`
- [ ] Remove `Message::ProcessOutput` variant (no longer needed)
- [ ] Keep `Message::Command(ServerCommand)` for shutdown signaling

#### Update: `process.rs`
- [ ] Replace `Event::ProcessMessage { ... }.emit()` with `StoreEvent::AppendLog { ... }.emit()`
- [ ] On process exit, emit `StoreEvent::ProcessExited { ... }`
- [ ] Track `Stream::Stdout` vs `Stream::Stderr` separately (currently both emit same event)

#### Update: `supervisor.rs`
- [ ] Initialize `StoreEvent::init()` before spawning processes
- [ ] Start `StateManager` task, obtain `StateHandle`
- [ ] Pass `StateHandle` back to caller (for TUI and HTTP)

### Phase 5: Update TUI (`cdi-tui/src/`)

#### Update: `app.rs`
- [ ] Accept `StateHandle` instead of building `ProcessTabGroup` from service names
- [ ] Remove `ProcessTab.data: Vec<String>` - no longer storing logs locally
- [ ] `render_selected_process_tab` reads from `state_handle.blocking_read().get_lines()`
- [ ] Process list reads from `state_handle.blocking_read().get_processes()`
- [ ] Remove `Event::ProcessMessage` match arm in `dispatch()`

#### Update: `lib.rs`
- [ ] Update `run()` signature to accept `StateHandle`

#### Update: `main.rs` (root crate)
- [ ] Initialize `StoreEvent::init()` alongside `Event::init()`
- [ ] Receive `StateHandle` from server, pass to TUI

### Phase 6: HTTP API (`cdi-server/src/api/`)

- [ ] Add `axum` and `serde_json` to `cdi-server/Cargo.toml`

#### New file: `mod.rs`
- [ ] Create axum router with `StateHandle` as app state
- [ ] `GET /processes` - list processes with status
- [ ] `GET /logs?process=&lines=&after_id=` - query logs
- [ ] `GET /summary` - overview for LLM context priming
- [ ] Spawn HTTP server on port 9876 (configurable via config?)

### Phase 7: Error Detection (`cdi-server/src/error_detection/`)

- [ ] Add `ErrorSeverity` enum (Error, Warning, Panic) to `cdi-shared`
- [ ] Add `DetectedError` struct (process, timestamp, severity, message, file, line)

#### New file: `mod.rs`
- [ ] Create `ErrorDetector` trait
- [ ] Implement `CargoErrorDetector` - parse rustc error format
- [ ] Implement `GenericErrorDetector` - regex patterns (ERROR, FATAL, panic, etc.)
- [ ] StateManager runs detection on each `AppendLog`, stores errors in `LogStore`
- [ ] Add `record_error()` and `get_errors()` to `LogStore` trait
- [ ] Add `GET /errors?process=&limit=` endpoint to HTTP API

### Phase 8: OpenCode Integration

- [ ] Create `.opencode/tool/devserver.ts` plugin
- [ ] `devserver_errors` tool - fetch errors from API
- [ ] `devserver_logs` tool - fetch recent logs  
- [ ] `devserver_summary` tool - get process overview

---

## Backlog

### TUI Improvements
- [ ] Make it more colorful
    - [x] Added ansi-to-tui crate for ansi color codes
    - [ ] Add theming
- [ ] Show navigation help
- [ ] Clearer separation between sidebar and output content
    - [x] Added right side border to tab area
- [ ] Add regex based highlighting
- [ ] Add filter to output
- [ ] Add output search
- [ ] Implement output copy
- [ ] Save output to file

### Features
- [ ] Define different combinations of services to start up
- [ ] Implement javascript monorepo functionality
    - Scan project folder for package.json
    - Look for dev command in each package
- [ ] Send output to LLM to explain error

---

## Completed
- [x] Allow config to set cwd of command
- [x] Look into why processes like python are not exiting
- [x] Figure out max rows per area for scrolling
