# TODO

## Current Sprint: StoreManager + LogStore Architecture

This refactor centralizes log storage in a `StoreManager`, enabling HTTP API access for LLM tools while keeping the TUI performant.

### Phase 1: Core Types (`cdi-shared/src/`)

#### File: `log.rs`
- [x] Add `Stream` enum (Stdout, Stderr)
- [x] Add `ProcessStatus` enum (Running, Stopped, Crashed)
- [x] Add `SessionInfo` struct (id: u64, started_at: u64)
- [x] Add `ProcessInfo` struct with `ProcessInfo::new()` constructor
    - `id: u64` - stable hash computed internally from (name, command, cwd)
    - `name: String`
    - `command: String` 
    - `cwd: Option<String>`
    - `pid: Option<usize>` - OS pid, None if not yet started
    - `status: ProcessStatus`
    - `exit_code: Option<i32>`
- [x] Add `LogLine` struct
    - `id: u64` - per-process monotonic
    - `process_id: u64` - stable hash, correlates across sessions
    - `session_id: u64` - which run of the tool
    - `timestamp: u64` - unix millis
    - `stream: Stream`
    - `content: String`
- [x] `compute_id()` encapsulated in `ProcessInfo::new()`

#### File: `event/store.rs`
- [x] RoCell-based channel implemented
- [x] `StoreEvent::AppendLog` uses `process_id: u64`
- [x] Update `StoreEvent::ProcessExited` to use `ProcessStatus` enum (currently uses `status: String`)

#### File: `event/ui.rs`
- [x] Renamed `Event` to `TuiEvent`
- [x] Removed `ProcessMessage` variant

#### File: `lib.rs`
- [x] Export new modules (event, ro_cell, log)

#### Bugs to fix:
- [x] `main.rs` line 29: typo `s.name.cloen()` → `s.name.clone()`
- [x] `process.rs` line 22: missing comma after `info: ProcessInfo`

### Phase 2: LogStore (`cdi-server/src/store/`) ✅ COMPLETE

#### File: `mod.rs`
- [x] `LogStore` trait complete
- [x] Removed `register_process()` - not needed
- [x] Removed `set_process_status()` - deferred for now
- [x] `get_process()` returns `&ProcessInfo` (unwraps internally)
- [x] Trait methods:
    - `append(&mut self, process_id: u64, stream: Stream, content: String)`
    - `get_lines(&self, process_id: u64, limit: Option<usize>) -> Vec<&LogLine>`
    - `get_lines_since(&self, process_id: u64, since_id: u64) -> Vec<&LogLine>`
    - `get_process(&self, process_id: u64) -> &ProcessInfo`
    - `get_processes(&self) -> Vec<&ProcessInfo>`

#### File: `memory.rs`
- [x] `ProcessData` struct: `{ info: ProcessInfo, logs: VecDeque<LogLine> }`
- [x] `MemoryStore` struct with fields: `processes`, `session_id`, `max_lines`
- [x] `MemoryStore::new(processes: Vec<ProcessInfo>, session_id: u64, max_lines: usize)`
    - Pre-allocates `HashMap` from process list
    - Pre-allocates `VecDeque::with_capacity(max_lines)` for each process
- [x] `append()` - derives id from last entry, generates timestamp, ring buffer eviction
- [x] `get_lines()` - with `Option<usize>` limit
- [x] `get_lines_since()` - binary search with `unwrap_or(0)` for evicted IDs
- [x] `get_process()` - unwraps internally
- [x] `get_processes()` - maps over values

### Phase 3: StoreManager (`cdi-server/src/store/`)

#### New file: `manager.rs`
- [ ] Create `StoreManager` struct
    - Owns `InMemoryStore` (concrete type for now, trait later if needed)
    - Receives `StoreEvent` via `StoreEvent::take()`
    - Runs in its own tokio task
    - On `AppendLog` → writes to store, emits `Event::Render`
    - On `ProcessExited` → updates process status, emits `Event::Render`

#### New file: `handle.rs`
- [ ] Create `StoreHandle` struct (clonable, shareable)
    - `store: Arc<RwLock<InMemoryStore>>` - direct read access for HTTP/TUI
    - `fn blocking_read(&self) -> RwLockReadGuard<InMemoryStore>` - for TUI
    - `async fn read(&self) -> RwLockReadGuard<InMemoryStore>` - for HTTP
- [ ] `StoreManager::start()` returns `StoreHandle`

### Phase 4: Refactor Supervisor & Process (`cdi-server/src/`)

#### Update: `server.rs`
- [ ] Remove `Message::ProcessOutput` variant (no longer needed)
- [x] `serve()` now takes `Vec<ProcessInfo>` instead of `Vec<Service>`

#### Update: `process.rs`
- [x] `Process::start()` takes `ProcessInfo` instead of `Service`
- [x] Uses `StoreEvent::AppendLog` instead of `Event::ProcessMessage`
- [x] Tracks `Stream::Stdout` vs `Stream::Stderr` separately
- [ ] On process exit, emit `StoreEvent::ProcessExited` (currently just logs a message)

#### Update: `supervisor.rs`
- [x] Uses `ProcessContext` struct (info + conn + handle)
- [x] Takes `Vec<ProcessInfo>` instead of `Vec<Service>`
- [ ] Initialize `StoreEvent::init()` before spawning processes
- [ ] Start `StoreManager` task, obtain `StoreHandle`
- [ ] Pass `StoreHandle` back to caller (for TUI and HTTP)

### Phase 5: Update TUI (`cdi-tui/src/`)

#### Update: `app.rs`
- [ ] Accept `StoreHandle` instead of building `ProcessTabGroup` from service names
- [ ] Remove `ProcessTab.data: Vec<String>` - no longer storing logs locally
- [ ] `render_selected_process_tab` reads from `store_handle.blocking_read().get_lines()`
- [ ] Process list reads from `store_handle.blocking_read().get_processes()`
- [ ] Remove `Event::ProcessMessage` match arm in `dispatch()`

#### Update: `lib.rs`
- [ ] Update `run()` signature to accept `StoreHandle`

#### Update: `main.rs` (root crate)
- [ ] Initialize `StoreEvent::init()` alongside `Event::init()`
- [ ] Receive `StoreHandle` from server, pass to TUI

### Phase 6: HTTP API (`cdi-server/src/api/`)

- [ ] Add `axum` and `serde_json` to `cdi-server/Cargo.toml`

#### New file: `mod.rs`
- [ ] Create axum router with `StoreHandle` as app state
- [ ] `GET /processes` - list processes with status
- [ ] `GET /logs?process=&lines=&after_id=` - query logs
- [ ] `GET /summary` - overview for LLM context priming
- [ ] Spawn HTTP server on port 9876 (configurable via config?)

### Phase 7: Error Detection (`cdi-server/src/error_detection/`)

- [ ] Add `ErrorSeverity` enum (Error, Warning, Panic) to `cdi-shared`
- [ ] Add `DetectedError` struct (process, timestamp, severity, message, file, line)

#### New file: `mod.rs`
- [ ] Create `ErrorDetector` trait
- [ ] Implement `CargoErrorDetector` - parse rustc error format
- [ ] Implement `GenericErrorDetector` - regex patterns (ERROR, FATAL, panic, etc.)
- [ ] StoreManager runs detection on each `AppendLog`, stores errors in `LogStore`
- [ ] Add `record_error()` and `get_errors()` to `LogStore` trait
- [ ] Add `GET /errors?process=&limit=` endpoint to HTTP API

### Phase 8: OpenCode Integration

- [ ] Create `.opencode/tool/devserver.ts` plugin
- [ ] `devserver_errors` tool - fetch errors from API
- [ ] `devserver_logs` tool - fetch recent logs  
- [ ] `devserver_summary` tool - get process overview

---

## Backlog

### TUI Improvements
- [ ] Make it more colorful
    - [x] Added ansi-to-tui crate for ansi color codes
    - [ ] Add theming
- [ ] Show navigation help
- [ ] Clearer separation between sidebar and output content
    - [x] Added right side border to tab area
- [ ] Add regex based highlighting
- [ ] Add filter to output
- [ ] Add output search
- [ ] Implement output copy
- [ ] Save output to file

### Features
- [ ] Define different combinations of services to start up
- [ ] Implement javascript monorepo functionality
    - Scan project folder for package.json
    - Look for dev command in each package
- [ ] Send output to LLM to explain error

---

## Completed
- [x] Allow config to set cwd of command
- [x] Look into why processes like python are not exiting
- [x] Figure out max rows per area for scrolling
