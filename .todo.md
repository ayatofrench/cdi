# TODO

## Current Sprint: Block Storage + Query Architecture

See `DESIGN.md` for full architecture details.

This refactor replaces per-line storage with block-based storage (similar to Tokio's mpsc channel) for memory efficiency, and separates storage from querying for clean client access.

### Phase 1: Core Types (`cdi-shared/src/`) - COMPLETE

- [x] `Stream` enum (Stdout, Stderr)
- [x] `ProcessStatus` enum (Running, Stopped, Crashed)
- [x] `SessionInfo` struct
- [x] `ProcessInfo` struct with stable hash ID
- [x] `LogLine` struct
- [x] `StoreEvent` and `TuiEvent` enums

### Phase 2: Block Storage (`cdi-server/src/store/`)

Replaces current `MemoryStore` with block-based storage.

#### File: `block.rs` (NEW)
- [ ] `LogLineMeta` struct (per-line, ~40 bytes)
    - `id: u64`
    - `timestamp: u128`
    - `stream: Stream`
    - `content_start: u32` (offset into string_data)
    - `content_len: u32`
- [ ] `Block` struct
    - `process_id: u64` (block header - shared by all lines)
    - `session_id: u64` (block header - shared by all lines)
    - `string_data: String` (concatenated log content)
    - `lines: Vec<LogLineMeta>`
- [ ] `Block::new()` with pre-allocated capacity
    - `BLOCK_CAP = 128` lines
- [ ] `Block::push(meta, content)` - append line
- [ ] `Block::is_full()` - returns `lines.len() >= BLOCK_CAP`
- [ ] `Block::get_content(&LogLineMeta) -> &str`
- [ ] `Block::iter() -> impl Iterator<Item = (&LogLineMeta, &str)>`
- [ ] Derive `Clone` for copy-on-write support

#### File: `memory.rs` (REFACTOR)
- [ ] `ProcessLogs` struct
    - `blocks: VecDeque<Arc<Block>>`
    - `max_blocks: usize`
- [ ] `ProcessLogs::new(max_blocks)`
- [ ] `ProcessLogs::append(meta, content)` using `Arc::make_mut`
- [ ] `ProcessLogs::snapshot() -> Vec<Arc<Block>>`
- [ ] `ProcessData` struct: `{ info: ProcessInfo, logs: ProcessLogs }`
- [ ] `MemoryStore` using new `ProcessLogs`
- [ ] Remove old `VecDeque<LogLine>` implementation

#### File: `snapshot.rs` (NEW)
- [ ] `LogSnapshot` struct
    - `blocks: Vec<Arc<Block>>`
    - `process_id: u64`
- [ ] `LogSnapshot::query() -> LogView`
- [ ] `LogSnapshot::len()` and `is_empty()`

#### File: `query.rs` (NEW)
- [ ] `LogQuery` builder struct
    - `process_id: Option<u64>`
    - `stream: Option<Stream>`
    - `after_id: Option<u64>`
    - `limit: Option<usize>`
- [ ] `LogQuery::new()`, `.process()`, `.stream()`, `.after()`, `.limit()`
- [ ] `LogView<'a>` struct (borrows snapshot)
- [ ] `LogView::iter() -> impl Iterator<Item = (&LogLineMeta, &str)>`
- [ ] `LogView::tail(n) -> Vec<(&LogLineMeta, &str)>`

#### File: `handle.rs` (NEW)
- [ ] `StoreHandle` struct: `Arc<RwLock<MemoryStore>>`
- [ ] `StoreHandle::snapshot(process_id) -> LogSnapshot`
- [ ] `StoreHandle::snapshot_all() -> HashMap<u64, LogSnapshot>`
- [ ] Implement `Clone`

#### File: `mod.rs` (UPDATE)
- [ ] Export new types: `Block`, `LogLineMeta`, `LogSnapshot`, `LogQuery`, `LogView`, `StoreHandle`
- [ ] Remove or deprecate old `LogStore` trait (concrete types for now)

### Phase 3: StoreManager (`cdi-server/src/store/`)

#### File: `manager.rs` (NEW)
- [ ] `StoreManager` struct owns `MemoryStore`
- [ ] `StoreManager::new(processes, session_id, max_blocks) -> (StoreManager, StoreHandle)`
- [ ] `StoreManager::run(events: Receiver<StoreEvent>)` - event loop
- [ ] On `AppendLog`: write to store, emit `TuiEvent::Render`
- [ ] On `ProcessExited`: update status, emit `TuiEvent::Render`

### Phase 4: Integrate with Supervisor (`cdi-server/src/`)

#### Update: `supervisor.rs`
- [ ] Initialize `StoreEvent::init()` before spawning processes
- [ ] Create `StoreManager`, obtain `StoreHandle`
- [ ] Spawn `StoreManager::run()` as tokio task
- [ ] Pass `StoreHandle` back to caller

#### Update: `process.rs`
- [ ] On process exit, emit `StoreEvent::ProcessExited`

#### Update: `server.rs`
- [ ] Remove `Message::ProcessOutput` variant if still present

### Phase 5: Update TUI (`cdi-tui/src/`)

#### Update: `app.rs`
- [ ] Accept `StoreHandle` in `App` struct
- [ ] Remove `ProcessTab.data: Vec<String>` - no local log storage
- [ ] Remove `ProcessTabGroup` - get process list from store
- [ ] `render_selected_process_tab`: use `store_handle.snapshot().query().tail(height)`
- [ ] Process list: use `store_handle.snapshot_all()` or similar

#### Update: `lib.rs`
- [ ] Update `run()` signature to accept `StoreHandle`

#### Update: `main.rs` (root)
- [ ] Initialize `StoreEvent::init()` alongside `TuiEvent::init()`
- [ ] Receive `StoreHandle` from server, pass to TUI

### Phase 6: CLI Client Protocol (`cdi-server/src/client/`)

External CLI connects via Unix socket for one-shot queries. LLM agents use the CLI.

See `DESIGN.md` "Communication Architecture" section for full details.

#### File: `protocol.rs` (NEW)
- [ ] `ClientRequest` enum
    - `ListProcesses`
    - `GetProcessStatus { process_id: String }`
    - `GetLogs { process_id: String, limit: usize, stream: Option<Stream> }`
    - `RestartProcess { process_id: String }`
    - `StopProcess { process_id: String }`
- [ ] `ClientResponse` enum
    - `Processes(Vec<ProcessInfo>)`
    - `Status(ProcessStatus)`
    - `Logs(Vec<LogLine>)`
    - `Ok`
    - `Error { message: String }`
- [ ] Derive `Serialize`, `Deserialize` for both

#### File: `handler.rs` (NEW)
- [ ] `handle_client(stream: UnixStream, store: StoreHandle, supervisor: SupervisorHandle)`
- [ ] Route requests to storage queries or supervisor commands
- [ ] Serialize responses as JSON

#### File: `listener.rs` (NEW)
- [ ] `ClientListener` struct
- [ ] `ClientListener::start(socket_path, store, supervisor)` - spawn accept loop
- [ ] Accept connections, spawn handler task per client
- [ ] Clean up socket file on shutdown

#### File: `mod.rs` (NEW)
- [ ] Export `ClientRequest`, `ClientResponse`, `ClientListener`

#### CLI Binary: `cdi-cli/` (NEW CRATE)
- [ ] Create new crate `cdi-cli`
- [ ] Connect to Unix socket
- [ ] Subcommands: `ps`, `logs`, `status`, `restart`, `stop`
- [ ] `pom ps` - list processes
- [ ] `pom logs <process> [--lines N] [--stdout|--stderr]` - get logs
- [ ] `pom status <process>` - get process status
- [ ] `pom restart <process>` - restart process
- [ ] `pom stop <process>` - stop process

### Phase 7: Error Detection (DEFERRED)

- [ ] `ErrorSeverity` enum
- [ ] `DetectedError` struct
- [ ] `ErrorDetector` trait
- [ ] `CargoErrorDetector`, `GenericErrorDetector` implementations
- [ ] Integration with StoreManager
- [ ] HTTP endpoint

### Phase 8: OpenCode Integration (DEFERRED)

LLM agents use the CLI directly - no special integration needed.

- [ ] Document CLI usage for LLM agents
- [ ] Example prompts for common operations

---

## Backlog

### TUI Improvements
- [ ] Add theming / make it more colorful
- [ ] Show navigation help
- [ ] Add regex based highlighting
- [ ] Add filter to output (uses `LogQuery`)
- [ ] Add output search (extends `LogQuery`)
- [ ] Implement output copy
- [ ] Save output to file

### Features
- [ ] Define different combinations of services to start up
- [ ] JavaScript monorepo functionality
- [ ] Send output to LLM to explain error

---

## Completed
- [x] Core types in `cdi-shared/src/log.rs`
- [x] Event system (`StoreEvent`, `TuiEvent`)
- [x] Basic `MemoryStore` (to be replaced with block-based version)
- [x] Process spawning with `ProcessInfo`
- [x] ANSI color support in TUI
- [x] Config cwd support
- [x] Process exit handling
